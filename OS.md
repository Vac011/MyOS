# OS开发

## boot

### boot sector(引导扇区)

- boot会被BIOS自动加载到内存地址`0x7c00`处, 因此要在boot.asm开头使用`org 0x7c00`指令表明代码的起始地址
- boot的开头部分是文件系统格式, 以`jmp short`指令开始, 紧接着是`nop`指令, 之后是OEM标识符和BPB等信息
- boot大小为512字节(1个扇区), 最后两个字节是必须是0x55aa, 才能被BIOS识别为引导扇区

### 汇编

- `$`表示当前地址, `$$`表示当前段的起始地址
- 使用`mov`指令将变量或标签赋给寄存器时, 实际上都是将对应的地址赋给寄存器
- 使用`[]`来访问(access, 存取)地址时, 必须在前面指定大小, 如`byte`, `word`, `dword`等; 但对于`mov`指令, 其要求源数据和目的数据位数必须相同, 则可以不指定大小, 汇编器会根据寄存器的大小自动选择
- 不论指定什么内存地址, 必须使用`段:基址`的方式, 表示段*16+基址, 16对应4位二进制数(1位16进制数), 在16位模式下最多进行1MB(实际为1114095, 略大于1M)寻址; 若`[]`中未指定段寄存器, 则默认为`DS`
- OUT指令操纵I/O端口, 其中源操作数根据端口位宽可以选用AL/AX/EAX寄存器；目的操作数可以是立即数或DX寄存器，其中立即数的取值范围只能是8位宽（0~FFh），而DX寄存器允许的取值范围是16位宽（0~FFFFh）
- 为了操作IA32_EFER寄存器，必须借助特殊汇编指令RDMSR/WRMSR。借助RDMSR/WRMSR指令可以访问64位的MSR寄存器, ECX寄存器（在64位模式下，RCX寄存器的高32位被忽略）传入寄存器地址, 目标MSR寄存器的值则是由EDX:EAX组成的64位寄存器代表(rd则写入, wr则读取)，其中的EDX寄存器保存MSR寄存器的高32位，EAX寄存器保存低32位。RDMSR与WRMSR指令必须在0特权级或实模式下执行。在使用这两条指令之前，应该使用CPUID指令（CPUID.01h:EDX[5] = 1）来检测处理器是否支持MSR寄存器组。

### BIOS中断

- int 0x10 控制显卡
  - AH=0x00 设置显示模式(VGA)
    - AL 显示模式
  - AH=0x09/0x0a/0x0e 在光标处显示字符
    - AL 字符
    - BH 页码
    - BL 字符/颜色属性
    - CX 字符重复次数
  - AH=0x13 显示字符串  
    - AL 字符串显示方式
    - BH 页码
    - BL 字符/颜色属性
    - CX 字符串长度
    - DH 行
    - DL 列
    - ES:BP 字符串地址
  - AH=0x4f 设置显示模式(SVGA(VBE))
    - AL=0x00 为调用者提供已安装的VBE软件和硬件信息, 保存在VBEInfoBlock结构中, 不同VBE版本的VbeInfoBlock信息块长度各不相同
      - ES:DI 指向用于存放VBEInfoBlock结构的缓冲区
    - AL=0x01, 用于获得指定模式号(来自于VideoModeList列表)的VBE显示模式扩展信息，这些信息会保存在一个名为ModeInfoBlock的结构里，结构长度为256B
      - CX 指定的显示模式号
      - ES:DI 指向用于存放ModeInfoBlock结构的缓冲区
    - AL=0x02, 用于初始化图形图像控制器并设置VBE显示模式
      - BX 低8位用于指定VBE模式号，高8位用于指定VBE模式属性
      - ES:DI 指向自定义的CRTCInfoBlock结构, BX的D11位用于选择刷新率，当D11=1时BIOS将使用CRTCInfoBlock结构来定制刷新率，当D11=0时ES:DI寄存器将被忽略。
    - AL=0x03, 用于获取当前使用的VBE显示模式信息
      - BX存放返回值
- int 0x13 外存读写
  - AH设置功能号
    - AH=0x02 读扇区
    - AH=0x03 写扇区
    - AH=0x04 检验扇区
  - AL设置读写扇区数
  - CH设置柱面号
  - CL设置扇区号
  - DH设置磁头号
  - DL设置驱动器号
    - 0x00~0x7f软盘
    - 0x80~0xff硬盘
  - ES:BX设置缓冲区地址(即读写数据的内存地址)
  - CF进位标志表示返回值, 0表示成功, 1表示失败
    - AH为错误码
    - AL为读写扇区数
- int 0x15 系统功能调用
  - EAX=0xe820 获取内存信息, 内存信息包括多个属性字段，所以用地址范围描述符(Address Range Descriptor Structure ，ARDS)进行描述, 每个描述符占20字节
    - EBX第一次调用时置为0, 之后为上一次调用时返回的地址
    - ECX=20 长度
    - EDX=0x534d4150 固定签名(对应ASCII码为SMAP)
    - ES:DI 缓冲区地址
    - CF进位标志表示返回值, 0表示成功, 1表示失败
    - EAX返回值"SMAP"签名, 0x534d4150
    - EBX返回值表示下一个ARDS的地址, 若在CF为0时返回0, 则表示这是最后一个ARDS


### 寄存器

- `X`表示16位拓展, `H`表示高8位, `L`表示低8位, 前缀`E`表示32位寄存器, `R`表示64位寄存器
- 虽然`AX`等可以作为通用寄存器, 在特定用途下使用时会被编译为不同长度的指令, 如`add`指令与`AX`寄存器搭配时会被编译为3字节码, 而与`CX`搭配时则会被编译为4字节码命令
- 只有`BX`、`BP`、`SI`、`DI`可以作为间接寻址的基址寄存器, 而`AX`、`CX`、`DX`、`SP`则不能
- 通用寄存器:
  - `AX` 累加寄存器
  - `BX` 基址寄存器
  - `CX` 计数寄存器
  - `DX` 数据寄存器
- 段寄存器: 段寄存器出现的原因在于8086中CPU的数据总线(即ALU算数逻辑单元)宽度为16位, 但地址总线宽度为20位, 为了能够访问1MB的内存空间, 采用了段地址+偏移地址的方式, 通过段寄存器存储段地址, 通过偏移地址存储偏移地址
  - `CS` 代码段寄存器, 与ip搭配使用, 作为代码段的段基址。取值时, 通过CS:IP的值(实际为段寄存器缓存区中的基地址base+ip)来确定下一条指令的地址, 然后ip+所读取的指令长度, 从而指向下一条指令, 然后重复上述过程
  - `DS` 数据段寄存器, 一般与bx、bp、si、di或立即数搭配使用, 作为数据段的段基址
  - `SS` 栈段寄存器, 与sp搭配使用, 作为栈段的段基址
  - `ES` 拓展段寄存器, 作为辅助段寄存器, 当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段
  - `FS` 标志段寄存器, 80386起增加的两个辅助段寄存器之一,在这之前只有一个辅助段寄存器ES, 指向当前活动线程的TEB结构(线程结构)
  - `GS` 全局段寄存器, 80386起增加的两个辅助段寄存器之一
- `BP` 基址指针寄存器
- `IP` 指令指针寄存器
- `SP` 栈指针寄存器
- `SI` 源变址寄存器
- `DI` 目的变址寄存器
- `CR0~4` 控制寄存器0~4

### 内存分布

- 0x00000-0x003ff: IVT(中断向量表)
- 0x00400-0x004ff: BDA(BIOS数据区)
- 0x00500-0x07bff: 保留
- 0x07c00-0x07dff: boot sector
- 0x07e00-0x9ffff: 保留
- 0xa0000-0xbffff: 显存
- 0xc0000-0xc7fff: 显卡BIOS
- 0xc8000-0xdffff: 保留
- 0xe0000-0xeffff: 扩展BIOS
- 0xf0000-0xfffff: 系统BIOS

## CPU模式

### real mode(16位)

- 实模式作为Intel处理器家族诞生的第一种运行模式已经存在了很多年。现在它仅用于引导启动操作系统和更新硬件设备的ROM固件，为了兼顾处理器的向下兼容性，它将一直存在于处理器的体系结构中。
- 在Intel官方白皮书中，英文术语Real Mode或Read-Address Mode均指实模式。实模式的特点是采用独特的段寻址方式进行地址访问，处理器在此模式可直接访问物理地址。在实模式下，通用寄存器的位宽只有16位，这使得实模式的寻址能力极其有限，就算借助段寻址方式，通常情况下实模式也只能寻址1 MB的物理地址空间。
- 实模式采用逻辑地址编址方式，通过段基地址加段内偏移地址的形式进行地址寻址，其书写格式为Segment：Offset。其中的段基地址值Segment保存在段寄存器中，段内偏移地址值Offset可以保存在寄存器内或使用立即数代替。
  - 虚拟地址是抽象地址的统称, 逻辑地址和线性地址都是虚拟地址的一种
    - 逻辑地址的形式是段地址:偏移地址, 逻辑地址最终都会被转换为线性地址, 再转换为物理地址
    - 线性地址是逻辑地址到物理地址的中间层, 通过逻辑地址中的段基地址与段内偏移地址经过一定的规则运算组合而成
  - 物理地址（Physical Address）是真实存在于硬件设备上的, 在处理器开启分页机制的情况下，线性地址需要经过页表映射才能转换成物理地址；否则线性地址将直接映射为物理地址。
- 实模式下逻辑地址的段基址通过左移4位并于段内偏移相加组成线性地址, 这种逻辑地址编址方式将原本只有16位寻址能力的处理器扩展至20位，通过特殊手段(big real mode)可将实模式的寻址能力扩展至4GB

### big real mode(16位)

- 在实模式下, 可以轻松操纵BIOS等, 但却只能访问1M的内存; 而在保护模式下, 可以访问4G的内存, 但却使用BIOS中断却比较麻烦。
- A20地址线是Intel 80286处理器引入的, 用于解决8086/8088处理器在实模式下只能寻址1MB内存的问题。开启A20地址线前, 处理器最多只能使用20根地址总线, 即段:偏移计算后的结果只能使用最多20位, 即1MB内存; 而开启A20地址线后, 处理器可以使用20根以上的地址总线, 段:偏移计算后的结果不必再回环, 可以访问1MB以上的内存(即使未进入保护模式)
- 为了减少地址转换时间与编码的复杂性，处理器为保护模式下的CS、SS、DS、ES、FS以及GS段寄存器各自加入了缓存区域，这些段寄存器的缓存区域记录着段描述符的基地址、限长和属性信息。当段选择子被处理器加载到段寄存器的可见区域(实际16位寄存器)后，处理器会自动将段描述符（包括基地址、长度和属性信息）载入到段寄存器的不可见区域(对应的段寄存器缓冲区), 处理器通过这些缓存信息，可直接进行地址转换，进而免去了重复读取内存中的段描述符的时间开销。
- 如果想在实模式下访问1M以上的空间，则需要修改段寄存器中的段界限，但是在实模式下又无法做出修改，所以必须先跳到保护模式下修改此值(给段寄存器赋值)，然后再跳回实模式。这时段寄存器缓冲区就存在一个远大于0xffff的段界限，即可访问相应大小的内存空间。此时处于的状态即称为big real mode

### protected mode(32位)

- 保护模式目前仅作为实模式到长模式的过渡模式存在，它是Intel处理器家族中的第二种运行模式。保护模式的特点是采用分段机制和分页机制进行地址访问，处理器在此模式下可访问4 GB的线性地址空间。
- 对于实模式的段机制而言，它仅仅规定了逻辑地址与线性地址间的转换方式，却没有限制访
问目标段的权限，这使得应用程序可以肆无忌惮地对系统核心进行操作。但在保护模式下，若想对系统核心进行操作必须拥有足够的访问权限才行，这就是保护的意义：操作系统可在处理器级防止程序有意或无意地破坏其他程序和数据。
- 虽然保护模式支持分段和分页两种管理机制，但是处理器必须先经过分段管理机制将逻辑地址转换成线性地址后，才能使用分页管理机制进一步把线性地址转换成物理地址（注意，分页管理机制是可选项，而分段管理机制是必选项）。
- 在保护模式下, 段:偏移不再解释为segment*16+offset, 而是先通过段寄存器中的段描述符索引找到相应的段描述符, 再通过段描述符中的基址和偏移地址计算出线性地址

### long mode(64位)

- 长模式也被称为IA-32e模式，它是Intel处理器家族中的第三种运行模式。长模式是在保护模式的基础上进行了扩展，它支持64位的线性地址空间，最大可寻址至16 EB（即2^64字节）。

### FAT12

- FAT(File Allocation Table)文件分配表
  - FAT文件系统以簇为单位来分配数据区的存储空间（扇区），数据区的簇号与FAT表的表项是一一对应关系。即使文件的长度只有一个字节，FAT也会为它分配一个簇的磁盘存储空间。
  - FAT文件系统的结构是由引导扇区、FAT表、根目录区、数据区组成
  - FAT表中的表项位宽与FAT类型有关，例如，FAT12文件系统的表项位宽为12 bit、FAT16文件系统的表项位宽为16 bit、FAT32文件系统的表项位宽为32 bit。
  - 由于FAT12的表项位宽为12位, 故两个表项共用3个字节, 且数据是有交叉的，第二个字节的高4位是下个簇号的低4位, 第二个字节的低4位是上个簇号的高4位
  - FAT的前两个表项FAT[0]和FAT[1]是保留表项，索引值从0开始, FAT表项值具有一下含义:
    - 0x000: 可用簇
    - 0x002~0xfef: 已用簇, 值表示文件下一个簇的簇号
    - 0xff0~0xff6: 保留簇
    - 0xff7: 坏簇
    - 0xff8~0xfff: 表明这是文件的最后一个簇
- 根目录项是一个由32B组成的结构体，其中记录着文件名字、长度以及数据起始簇号等信息

### GDT

- GDT(Global (segment) Descriptor Table)全局描述符表, 整个系统只有一张, 用于存储段描述符, 一个段描述符占8字节(即一个GDT表项占64位), 包括段基址、段界限(长度)、段属性等信息
- 在16位下段寄存器存放的是段基地址, 计算地址需要将段寄存器乘以16, 加上偏移地址;  
而在32位下, 段寄存器存放的是GDT表中的索引值(高13位), 用于在GDT中选择段的基础地址再加上偏移地址。  
但无论是16位还是32位, 段寄存器大小都是16位
- 由于段寄存器为16位, 但低3位为指示信息, 因此最多只能有2^13=8192个段, 8192*8B=64KB, 因此GDT表的大小为64KB, 存储在内存中的某个位置, 由开发人员自行设置, 并由CPU的GDTR特殊寄存器指向
- GDTR(Global Descriptor Table Register)全局描述符表寄存器, 用于存储GDT表的基址和界限, 48位, 高32位为GDT表的基址, 低16位为GDT表的限长
- LDT(Local Descriptor Table)局部描述符表, 每个进程可以私有一个LDT, 用于记录本任务中涉及的各个代码段、数据段和堆栈段以及本任务的使用的门描述符。LDTR(Local Descriptor Table Register)局部描述符表寄存器, 16位, 高13位为LDT表的索引, 低3位为指示信息

### IDT

- IDT(Interrupt Descriptor Table)中断描述符表, 用于存储中断描述符, 一个中断描述符占8字节(即一个IDT表项占64位), 包括中断处理程序的段选择子、中断处理程序的偏移地址、中断门属性等信息
- 最多设置256个中断号, 对应256个中断处理函数
- IDTR(Interrupt Descriptor Table Register)中断描述符表寄存器, 用于存储IDT表的基址和界限, 48位, 高32位为IDT表的基址, 低16位为IDT表的限长

### PIC

- PIC(Programmable Interrupt Controller)可编程中断控制器, 用于处理中断信号, 包含两个级联的芯片, 主片和从片, 主片连接到CPU的IRQ0-IRQ7(interrupt request), 从片连接到主片的IRQ2
- 主片的端口号为0x20(命令端口)和0x21(数据端口), 从片的端口号为0xa0(命令端口)和0xa1(数据端口)
- PIC的寄存器都是8位的, 通过向命令端口写入不同的命令, 可以设置PIC的工作模式, 如初始化、中断屏蔽、中断结束等
  - ICW1(Initial Control Word 1)初始化命令字1, 与ICW4配合使用, 与PIC主板配线方式、中断信号的电气特性有关, 一般为固定值
  - ICW2(Initial Control Word 2)初始化命令字2, 
  - ICW3(Initial Control Word 3)初始化命令字3, 与主从连接设定有关, 值为00000100, 由于硬件已不可更改, 故该项固定
  - ICW4(Initial Control Word 4)初始化命令字4
  - OCW(Operational Command Word)操作命令字
  - IMR(Interrupt Mask Register)中断屏蔽寄存器, 8位分别对应8路IRQ信号
